{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"workspaceName": {
			"type": "string",
			"metadata": "Workspace name",
			"defaultValue": "contoso200709"
		},
		"contoso200709-WorkspaceDefaultSqlServer_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'contoso200709-WorkspaceDefaultSqlServer'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=tcp:contoso200709.sql.azuresynapse.net,1433;Initial Catalog=@{linkedService().DBName}"
		},
		"ls_on_prem_sql_server_password": {
			"type": "secureString",
			"metadata": "Secure string for 'password' of 'ls_on_prem_sql_server'"
		},
		"contoso200709-WorkspaceDefaultStorage_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://contosomang200709.dfs.core.windows.net"
		},
		"ls_dl_contoso0709_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://dlcontoso.dfs.core.windows.net/"
		},
		"ls_on_prem_sql_server_properties_typeProperties_server": {
			"type": "string",
			"defaultValue": "KHANBIENG\\SQLEXPRESS"
		},
		"ls_on_prem_sql_server_properties_typeProperties_database": {
			"type": "string",
			"defaultValue": "AdventureWorks"
		},
		"ls_on_prem_sql_server_properties_typeProperties_userName": {
			"type": "string",
			"defaultValue": "sa"
		}
	},
	"variables": {
		"workspaceId": "[concat('Microsoft.Synapse/workspaces/', parameters('workspaceName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('workspaceName'), '/Gold_Layer')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "DimProduct",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Gold_Product",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": true
							}
						}
					},
					{
						"name": "FactOrderDetail",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "FactOrder",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Gold_Fact_Order_Detail",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": true
							}
						}
					},
					{
						"name": "FactOrder",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "DimSalesPerson",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Gold_Fact_Order",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": true
							}
						}
					},
					{
						"name": "DimSalesPerson",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "DimRetailCustomer",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Gold_Sales_Person",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": true
							}
						}
					},
					{
						"name": "DimRetailCustomer",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "DimReseller",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Gold_Retail_Customer",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": true
							}
						}
					},
					{
						"name": "DimReseller",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "DimProduct",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Gold_Reseller",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": true
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Gold_Product')]",
				"[concat(variables('workspaceId'), '/notebooks/Gold_Fact_Order_Detail')]",
				"[concat(variables('workspaceId'), '/notebooks/Gold_Fact_Order')]",
				"[concat(variables('workspaceId'), '/notebooks/Gold_Sales_Person')]",
				"[concat(variables('workspaceId'), '/notebooks/Gold_Retail_Customer')]",
				"[concat(variables('workspaceId'), '/notebooks/Gold_Reseller')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/On_Prem_To_DL')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ForEachSalesTable",
						"type": "ForEach",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@pipeline().parameters.sales_tables_loop",
								"type": "Expression"
							},
							"isSequential": false,
							"activities": [
								{
									"name": "Last_cdc_date",
									"type": "Lookup",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "JsonSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "JsonReadSettings"
											}
										},
										"dataset": {
											"referenceName": "ds_cdcjson",
											"type": "DatasetReference",
											"parameters": {
												"p_folder": {
													"value": "@concat('sales/', item().table)",
													"type": "Expression"
												}
											}
										},
										"firstRowOnly": false
									}
								},
								{
									"name": "CheckNewRecords",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "Last_cdc_date",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_on_prem_sql_server",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "SELECT COUNT(*) as newrows FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate),activity('Last_cdc_date').output.value[0].cdc,item().backdate)}'",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								},
								{
									"name": "IfNewRecords",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "CheckNewRecords",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@greater(activity('CheckNewRecords').output.resultSets[0].rows[0].newrows, 0)",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "Database2DataLake",
												"type": "Copy",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "SqlServerSource",
														"sqlReaderQuery": {
															"value": "SELECT * FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate), activity('Last_cdc_date').output.value[0].cdc, item().backdate)}'",
															"type": "Expression"
														},
														"queryTimeout": "02:00:00",
														"partitionOption": "None"
													},
													"sink": {
														"type": "ParquetSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "ParquetWriteSettings"
														}
													},
													"enableStaging": false,
													"translator": {
														"type": "TabularTranslator",
														"typeConversion": true,
														"typeConversionSettings": {
															"allowDataTruncation": true,
															"treatBooleanAsNumber": false
														}
													}
												},
												"inputs": [
													{
														"referenceName": "ls_AdventureWorks_DB",
														"type": "DatasetReference",
														"parameters": {}
													}
												],
												"outputs": [
													{
														"referenceName": "ls_dl_sales_tables",
														"type": "DatasetReference",
														"parameters": {
															"P_folder": {
																"value": "@concat('sales/', item().table)",
																"type": "Expression"
															},
															"p_file": {
																"value": "@{item().table}",
																"type": "Expression"
															}
														}
													}
												]
											},
											{
												"name": "NewMaxDate",
												"type": "Script",
												"dependsOn": [
													{
														"activity": "Database2DataLake",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"linkedServiceName": {
													"referenceName": "ls_on_prem_sql_server",
													"type": "LinkedServiceReference"
												},
												"typeProperties": {
													"scripts": [
														{
															"type": "Query",
															"text": {
																"value": "SELECT MAX(@{item().cdc}) as cdc FROM @{item().schema}.@{item().table}",
																"type": "Expression"
															}
														}
													],
													"scriptBlockExecutionTimeout": "02:00:00"
												}
											},
											{
												"name": "UpdateCdcJson",
												"type": "Copy",
												"dependsOn": [
													{
														"activity": "NewMaxDate",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "JsonSource",
														"additionalColumns": [
															{
																"name": "cdc",
																"value": {
																	"value": "@activity('NewMaxDate').output.resultSets[0].rows[0].cdc",
																	"type": "Expression"
																}
															}
														],
														"storeSettings": {
															"type": "AzureBlobFSReadSettings",
															"recursive": true,
															"enablePartitionDiscovery": false
														},
														"formatSettings": {
															"type": "JsonReadSettings"
														}
													},
													"sink": {
														"type": "JsonSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "JsonWriteSettings"
														}
													},
													"enableStaging": false
												},
												"inputs": [
													{
														"referenceName": "ds_empty_json",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('sales/',item().table)",
																"type": "Expression"
															}
														}
													}
												],
												"outputs": [
													{
														"referenceName": "ds_cdcjson",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('sales/',item().table)",
																"type": "Expression"
															}
														}
													}
												]
											}
										]
									}
								}
							]
						}
					},
					{
						"name": "ForEachPersonTable",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "ForEachSalesTable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@pipeline().parameters.person_tables_loop",
								"type": "Expression"
							},
							"isSequential": false,
							"activities": [
								{
									"name": "PLast_cdc_date",
									"type": "Lookup",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "JsonSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "JsonReadSettings"
											}
										},
										"dataset": {
											"referenceName": "ds_cdcjson",
											"type": "DatasetReference",
											"parameters": {
												"p_folder": {
													"value": "@concat('person/', item().table)",
													"type": "Expression"
												}
											}
										},
										"firstRowOnly": false
									}
								},
								{
									"name": "PCheckNewRecords",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "PLast_cdc_date",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_on_prem_sql_server",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "SELECT COUNT(*) as newrows FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate),activity('PLast_cdc_date').output.value[0].cdc,item().backdate)}'",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								},
								{
									"name": "PIfNewRecords",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "PCheckNewRecords",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@greater(activity('PCheckNewRecords').output.resultSets[0].rows[0].newrows, 0)",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "PDatabase2DataLake",
												"type": "Copy",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "SqlServerSource",
														"sqlReaderQuery": {
															"value": "SELECT * FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate), activity('PLast_cdc_date').output.value[0].cdc, item().backdate)}'",
															"type": "Expression"
														},
														"queryTimeout": "02:00:00",
														"partitionOption": "None"
													},
													"sink": {
														"type": "ParquetSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "ParquetWriteSettings"
														}
													},
													"enableStaging": false,
													"translator": {
														"type": "TabularTranslator",
														"typeConversion": true,
														"typeConversionSettings": {
															"allowDataTruncation": true,
															"treatBooleanAsNumber": false
														}
													}
												},
												"inputs": [
													{
														"referenceName": "ls_AdventureWorks_DB",
														"type": "DatasetReference",
														"parameters": {}
													}
												],
												"outputs": [
													{
														"referenceName": "ls_dl_sales_tables",
														"type": "DatasetReference",
														"parameters": {
															"P_folder": {
																"value": "@concat('person/', item().table)",
																"type": "Expression"
															},
															"p_file": {
																"value": "@{item().table}",
																"type": "Expression"
															}
														}
													}
												]
											},
											{
												"name": "PNewMaxDate",
												"type": "Script",
												"dependsOn": [
													{
														"activity": "PDatabase2DataLake",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"linkedServiceName": {
													"referenceName": "ls_on_prem_sql_server",
													"type": "LinkedServiceReference"
												},
												"typeProperties": {
													"scripts": [
														{
															"type": "Query",
															"text": {
																"value": "SELECT MAX(@{item().cdc}) as cdc FROM @{item().schema}.@{item().table}",
																"type": "Expression"
															}
														}
													],
													"scriptBlockExecutionTimeout": "02:00:00"
												}
											},
											{
												"name": "PUpdateCdcJson",
												"type": "Copy",
												"dependsOn": [
													{
														"activity": "PNewMaxDate",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "JsonSource",
														"additionalColumns": [
															{
																"name": "cdc",
																"value": {
																	"value": "@activity('PNewMaxDate').output.resultSets[0].rows[0].cdc",
																	"type": "Expression"
																}
															}
														],
														"storeSettings": {
															"type": "AzureBlobFSReadSettings",
															"recursive": true,
															"enablePartitionDiscovery": false
														},
														"formatSettings": {
															"type": "JsonReadSettings"
														}
													},
													"sink": {
														"type": "JsonSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "JsonWriteSettings"
														}
													},
													"enableStaging": false
												},
												"inputs": [
													{
														"referenceName": "ds_empty_json",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('person/',item().table)",
																"type": "Expression"
															}
														}
													}
												],
												"outputs": [
													{
														"referenceName": "ds_cdcjson",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('person/',item().table)",
																"type": "Expression"
															}
														}
													}
												]
											}
										]
									}
								}
							]
						}
					},
					{
						"name": "ForEachProductionTable",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "ForEachPersonTable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@pipeline().parameters.production_tables_loop",
								"type": "Expression"
							},
							"isSequential": false,
							"activities": [
								{
									"name": "Prod_Last_cdc_date",
									"type": "Lookup",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "JsonSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "JsonReadSettings"
											}
										},
										"dataset": {
											"referenceName": "ds_cdcjson",
											"type": "DatasetReference",
											"parameters": {
												"p_folder": {
													"value": "@concat('production/', item().table)",
													"type": "Expression"
												}
											}
										},
										"firstRowOnly": false
									}
								},
								{
									"name": "Prod_CheckNewRecords",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "Prod_Last_cdc_date",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_on_prem_sql_server",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "SELECT COUNT(*) as newrows FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate),activity('Prod_Last_cdc_date').output.value[0].cdc,item().backdate)}'",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								},
								{
									"name": "Prod_IfNewRecords",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "Prod_CheckNewRecords",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@greater(activity('Prod_CheckNewRecords').output.resultSets[0].rows[0].newrows, 0)",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "Prod_Database2DataLake",
												"type": "Copy",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "SqlServerSource",
														"sqlReaderQuery": {
															"value": "SELECT * FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate), activity('Prod_Last_cdc_date').output.value[0].cdc, item().backdate)}'",
															"type": "Expression"
														},
														"queryTimeout": "02:00:00",
														"partitionOption": "None"
													},
													"sink": {
														"type": "ParquetSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "ParquetWriteSettings"
														}
													},
													"enableStaging": false,
													"translator": {
														"type": "TabularTranslator",
														"typeConversion": true,
														"typeConversionSettings": {
															"allowDataTruncation": true,
															"treatBooleanAsNumber": false
														}
													}
												},
												"inputs": [
													{
														"referenceName": "ls_AdventureWorks_DB",
														"type": "DatasetReference",
														"parameters": {}
													}
												],
												"outputs": [
													{
														"referenceName": "ls_dl_sales_tables",
														"type": "DatasetReference",
														"parameters": {
															"P_folder": {
																"value": "@concat('production/', item().table)",
																"type": "Expression"
															},
															"p_file": {
																"value": "@{item().table}",
																"type": "Expression"
															}
														}
													}
												]
											},
											{
												"name": "Prod_NewMaxDate",
												"type": "Script",
												"dependsOn": [
													{
														"activity": "Prod_Database2DataLake",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"linkedServiceName": {
													"referenceName": "ls_on_prem_sql_server",
													"type": "LinkedServiceReference"
												},
												"typeProperties": {
													"scripts": [
														{
															"type": "Query",
															"text": {
																"value": "SELECT MAX(@{item().cdc}) as cdc FROM @{item().schema}.@{item().table}",
																"type": "Expression"
															}
														}
													],
													"scriptBlockExecutionTimeout": "02:00:00"
												}
											},
											{
												"name": "Prod_UpdateCdcJson",
												"type": "Copy",
												"dependsOn": [
													{
														"activity": "Prod_NewMaxDate",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "JsonSource",
														"additionalColumns": [
															{
																"name": "cdc",
																"value": {
																	"value": "@activity('Prod_NewMaxDate').output.resultSets[0].rows[0].cdc",
																	"type": "Expression"
																}
															}
														],
														"storeSettings": {
															"type": "AzureBlobFSReadSettings",
															"recursive": true,
															"enablePartitionDiscovery": false
														},
														"formatSettings": {
															"type": "JsonReadSettings"
														}
													},
													"sink": {
														"type": "JsonSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "JsonWriteSettings"
														}
													},
													"enableStaging": false
												},
												"inputs": [
													{
														"referenceName": "ds_empty_json",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('production/',item().table)",
																"type": "Expression"
															}
														}
													}
												],
												"outputs": [
													{
														"referenceName": "ds_cdcjson",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('production/',item().table)",
																"type": "Expression"
															}
														}
													}
												]
											}
										]
									}
								}
							]
						}
					},
					{
						"name": "ForEachHRTable",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "ForEachProductionTable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@pipeline().parameters.hr_tables_loop",
								"type": "Expression"
							},
							"isSequential": false,
							"activities": [
								{
									"name": "HR_Last_cdc_date",
									"type": "Lookup",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "JsonSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "JsonReadSettings"
											}
										},
										"dataset": {
											"referenceName": "ds_cdcjson",
											"type": "DatasetReference",
											"parameters": {
												"p_folder": {
													"value": "@concat('humanresources/', item().table)",
													"type": "Expression"
												}
											}
										},
										"firstRowOnly": false
									}
								},
								{
									"name": "HR_CheckNewRecords",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "HR_Last_cdc_date",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_on_prem_sql_server",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "SELECT COUNT(*) as newrows FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate),activity('HR_Last_cdc_date').output.value[0].cdc,item().backdate)}'",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								},
								{
									"name": "HR_IfNewRecords",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "HR_CheckNewRecords",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@greater(activity('HR_CheckNewRecords').output.resultSets[0].rows[0].newrows, 0)",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "HR_Database2DataLake",
												"type": "Copy",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "SqlServerSource",
														"sqlReaderQuery": {
															"value": "SELECT * FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate), activity('HR_Last_cdc_date').output.value[0].cdc, item().backdate)}'",
															"type": "Expression"
														},
														"queryTimeout": "02:00:00",
														"partitionOption": "None"
													},
													"sink": {
														"type": "ParquetSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "ParquetWriteSettings"
														}
													},
													"enableStaging": false,
													"translator": {
														"type": "TabularTranslator",
														"typeConversion": true,
														"typeConversionSettings": {
															"allowDataTruncation": true,
															"treatBooleanAsNumber": false
														}
													}
												},
												"inputs": [
													{
														"referenceName": "ls_AdventureWorks_DB",
														"type": "DatasetReference",
														"parameters": {}
													}
												],
												"outputs": [
													{
														"referenceName": "ls_dl_sales_tables",
														"type": "DatasetReference",
														"parameters": {
															"P_folder": {
																"value": "@concat('humanresources/', item().table)",
																"type": "Expression"
															},
															"p_file": {
																"value": "@{item().table}",
																"type": "Expression"
															}
														}
													}
												]
											},
											{
												"name": "HR_NewMaxDate",
												"type": "Script",
												"dependsOn": [
													{
														"activity": "HR_Database2DataLake",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"linkedServiceName": {
													"referenceName": "ls_on_prem_sql_server",
													"type": "LinkedServiceReference"
												},
												"typeProperties": {
													"scripts": [
														{
															"type": "Query",
															"text": {
																"value": "SELECT MAX(@{item().cdc}) as cdc FROM @{item().schema}.@{item().table}",
																"type": "Expression"
															}
														}
													],
													"scriptBlockExecutionTimeout": "02:00:00"
												}
											},
											{
												"name": "HR_UpdateCdcJson",
												"type": "Copy",
												"dependsOn": [
													{
														"activity": "HR_NewMaxDate",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "JsonSource",
														"additionalColumns": [
															{
																"name": "cdc",
																"value": {
																	"value": "@activity('HR_NewMaxDate').output.resultSets[0].rows[0].cdc",
																	"type": "Expression"
																}
															}
														],
														"storeSettings": {
															"type": "AzureBlobFSReadSettings",
															"recursive": true,
															"enablePartitionDiscovery": false
														},
														"formatSettings": {
															"type": "JsonReadSettings"
														}
													},
													"sink": {
														"type": "JsonSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "JsonWriteSettings"
														}
													},
													"enableStaging": false
												},
												"inputs": [
													{
														"referenceName": "ds_empty_json",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('humanresources/',item().table)",
																"type": "Expression"
															}
														}
													}
												],
												"outputs": [
													{
														"referenceName": "ds_cdcjson",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('humanresources/',item().table)",
																"type": "Expression"
															}
														}
													}
												]
											}
										]
									}
								}
							]
						}
					},
					{
						"name": "ForEachPurchasingTable",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "ForEachHRTable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@pipeline().parameters.purchasing_tables_loop",
								"type": "Expression"
							},
							"isSequential": false,
							"activities": [
								{
									"name": "Prch_Last_cdc_date",
									"type": "Lookup",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "JsonSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "JsonReadSettings"
											}
										},
										"dataset": {
											"referenceName": "ds_cdcjson",
											"type": "DatasetReference",
											"parameters": {
												"p_folder": {
													"value": "@concat('purchasing/', item().table)",
													"type": "Expression"
												}
											}
										},
										"firstRowOnly": false
									}
								},
								{
									"name": "Prch_CheckNewRecords",
									"type": "Script",
									"dependsOn": [
										{
											"activity": "Prch_Last_cdc_date",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"linkedServiceName": {
										"referenceName": "ls_on_prem_sql_server",
										"type": "LinkedServiceReference"
									},
									"typeProperties": {
										"scripts": [
											{
												"type": "Query",
												"text": {
													"value": "SELECT COUNT(*) as newrows FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate),activity('Prch_Last_cdc_date').output.value[0].cdc,item().backdate)}'",
													"type": "Expression"
												}
											}
										],
										"scriptBlockExecutionTimeout": "02:00:00"
									}
								},
								{
									"name": "Prch_IfNewRecords",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "Prch_CheckNewRecords",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@greater(activity('Prch_CheckNewRecords').output.resultSets[0].rows[0].newrows, 0)",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "Prch_Database2DataLake",
												"type": "Copy",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "SqlServerSource",
														"sqlReaderQuery": {
															"value": "SELECT * FROM @{item().schema}.@{item().table} WHERE @{item().cdc} > '@{if(empty(item().backdate), activity('Prch_Last_cdc_date').output.value[0].cdc, item().backdate)}'",
															"type": "Expression"
														},
														"queryTimeout": "02:00:00",
														"partitionOption": "None"
													},
													"sink": {
														"type": "ParquetSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "ParquetWriteSettings"
														}
													},
													"enableStaging": false,
													"translator": {
														"type": "TabularTranslator",
														"typeConversion": true,
														"typeConversionSettings": {
															"allowDataTruncation": true,
															"treatBooleanAsNumber": false
														}
													}
												},
												"inputs": [
													{
														"referenceName": "ls_AdventureWorks_DB",
														"type": "DatasetReference",
														"parameters": {}
													}
												],
												"outputs": [
													{
														"referenceName": "ls_dl_sales_tables",
														"type": "DatasetReference",
														"parameters": {
															"P_folder": {
																"value": "@concat('purchasing/', item().table)",
																"type": "Expression"
															},
															"p_file": {
																"value": "@{item().table}",
																"type": "Expression"
															}
														}
													}
												]
											},
											{
												"name": "Prch_NewMaxDate",
												"type": "Script",
												"dependsOn": [
													{
														"activity": "Prch_Database2DataLake",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"linkedServiceName": {
													"referenceName": "ls_on_prem_sql_server",
													"type": "LinkedServiceReference"
												},
												"typeProperties": {
													"scripts": [
														{
															"type": "Query",
															"text": {
																"value": "SELECT MAX(@{item().cdc}) as cdc FROM @{item().schema}.@{item().table}",
																"type": "Expression"
															}
														}
													],
													"scriptBlockExecutionTimeout": "02:00:00"
												}
											},
											{
												"name": "Prch_UpdateCdcJson",
												"type": "Copy",
												"dependsOn": [
													{
														"activity": "Prch_NewMaxDate",
														"dependencyConditions": [
															"Succeeded"
														]
													}
												],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"source": {
														"type": "JsonSource",
														"additionalColumns": [
															{
																"name": "cdc",
																"value": {
																	"value": "@activity('Prch_NewMaxDate').output.resultSets[0].rows[0].cdc",
																	"type": "Expression"
																}
															}
														],
														"storeSettings": {
															"type": "AzureBlobFSReadSettings",
															"recursive": true,
															"enablePartitionDiscovery": false
														},
														"formatSettings": {
															"type": "JsonReadSettings"
														}
													},
													"sink": {
														"type": "JsonSink",
														"storeSettings": {
															"type": "AzureBlobFSWriteSettings"
														},
														"formatSettings": {
															"type": "JsonWriteSettings"
														}
													},
													"enableStaging": false
												},
												"inputs": [
													{
														"referenceName": "ds_empty_json",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('purchasing/',item().table)",
																"type": "Expression"
															}
														}
													}
												],
												"outputs": [
													{
														"referenceName": "ds_cdcjson",
														"type": "DatasetReference",
														"parameters": {
															"p_folder": {
																"value": "@concat('purchasing/',item().table)",
																"type": "Expression"
															}
														}
													}
												]
											}
										]
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"sales_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Sales",
								"table": "CountryRegionCurrency",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "CreditCard",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "Currency",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "CurrencyRate",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "Customer",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "PersonCreditCard",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesOrderDetail",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesOrderHeader",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesOrderHeaderSalesReason",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesReason",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesTaxRate",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesTerritory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SpecialOffer",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SpecialOfferProduct",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "Store",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesPerson",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"person_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Person",
								"table": "vw_Address_Clean",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "AddressType",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "BusinessEntity",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "BusinessEntityAddress",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "BusinessEntityContact",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "ContactType",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "CountryRegion",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "EmailAddress",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "Password",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "Person",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "PersonPhone",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "PhoneNumberType",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "StateProvince",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"production_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Production",
								"table": "BillOfMaterials",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "Culture",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "Location",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "Product",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductCategory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductDescription",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductInventory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductModel",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductModelProductDescriptionCulture",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductPhoto",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductProductPhoto",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductReview",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductSubcategory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ScrapReason",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "TransactionHistory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "TransactionHistoryArchive",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "UnitMeasure",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "WorkOrder",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "WorkOrderRouting",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"hr_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "HumanResources",
								"table": "Shift",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "Department",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "vw_Employee_Clean",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "EmployeeDepartmentHistory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "EmployeePayHistory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "JobCandidate",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"purchasing_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Purchasing",
								"table": "ProductVendor",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "PurchaseOrderDetail",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "PurchaseOrderHeader",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "ShipMethod",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "Vendor",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					}
				},
				"variables": {
					"current_timestamp": {
						"type": "String"
					}
				},
				"annotations": [],
				"lastPublishTime": "2026-01-11T10:05:44Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_cdcjson')]",
				"[concat(variables('workspaceId'), '/linkedServices/ls_on_prem_sql_server')]",
				"[concat(variables('workspaceId'), '/datasets/ls_AdventureWorks_DB')]",
				"[concat(variables('workspaceId'), '/datasets/ls_dl_sales_tables')]",
				"[concat(variables('workspaceId'), '/datasets/ds_empty_json')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Parent_Pipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Bronze",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "On_Prem_To_DL",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"sales_tables_loop": {
									"value": "@pipeline().parameters.sales_tables_loop",
									"type": "Expression"
								},
								"person_tables_loop": {
									"value": "@pipeline().parameters.person_tables_loop",
									"type": "Expression"
								},
								"production_tables_loop": {
									"value": "@pipeline().parameters.production_tables_loop",
									"type": "Expression"
								},
								"hr_tables_loop": {
									"value": "@pipeline().parameters.hr_tables_loop",
									"type": "Expression"
								},
								"purchasing_tables_loop": {
									"value": "@pipeline().parameters.purchasing_tables_loop",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "Silver",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Bronze",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "Silver_Layer",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Gold",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Silver",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "Gold_Layer",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"sales_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Sales",
								"table": "CountryRegionCurrency",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "CreditCard",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "Currency",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "CurrencyRate",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "Customer",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "PersonCreditCard",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesOrderDetail",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesOrderHeader",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesOrderHeaderSalesReason",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesReason",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesTaxRate",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesTerritory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SpecialOffer",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SpecialOfferProduct",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "Store",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Sales",
								"table": "SalesPerson",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"person_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Person",
								"table": "vw_Address_Clean",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "AddressType",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "BusinessEntity",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "BusinessEntityAddress",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "BusinessEntityContact",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "ContactType",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "CountryRegion",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "EmailAddress",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "Password",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "Person",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "PersonPhone",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "PhoneNumberType",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Person",
								"table": "StateProvince",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"production_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Production",
								"table": "BillOfMaterials",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "Culture",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "Location",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "Product",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductCategory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductDescription",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductInventory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductModel",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductModelProductDescriptionCulture",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductPhoto",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductProductPhoto",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductReview",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ProductSubcategory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "ScrapReason",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "TransactionHistory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "TransactionHistoryArchive",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "UnitMeasure",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "WorkOrder",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Production",
								"table": "WorkOrderRouting",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"hr_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "HumanResources",
								"table": "Shift",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "Department",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "vw_Employee_Clean",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "EmployeeDepartmentHistory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "EmployeePayHistory",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "HumanResources",
								"table": "JobCandidate",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					},
					"purchasing_tables_loop": {
						"type": "array",
						"defaultValue": [
							{
								"schema": "Purchasing",
								"table": "ProductVendor",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "PurchaseOrderDetail",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "PurchaseOrderHeader",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "ShipMethod",
								"cdc": "ModifiedDate",
								"backdate": ""
							},
							{
								"schema": "Purchasing",
								"table": "Vendor",
								"cdc": "ModifiedDate",
								"backdate": ""
							}
						]
					}
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/On_Prem_To_DL')]",
				"[concat(variables('workspaceId'), '/pipelines/Silver_Layer')]",
				"[concat(variables('workspaceId'), '/pipelines/Gold_Layer')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Silver_Layer')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Sales_Data_Model_Tables",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Silver",
								"type": "NotebookReference"
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"annotations": [],
				"lastPublishTime": "2026-01-08T13:17:06Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Silver')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_cdcjson')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_contoso0709",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"p_folder": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "cdc.json",
						"folderPath": {
							"value": "@dataset().p_folder",
							"type": "Expression"
						},
						"fileSystem": "etlcontrol"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_contoso0709')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_empty_json')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_contoso0709",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"p_folder": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "empty.json",
						"folderPath": {
							"value": "@dataset().p_folder",
							"type": "Expression"
						},
						"fileSystem": "etlcontrol"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_contoso0709')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_AdventureWorks_DB')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_on_prem_sql_server",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_on_prem_sql_server')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_dl_sales_tables')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_dl_contoso0709",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"P_folder": {
						"type": "string"
					},
					"p_file": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().p_file",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().P_folder",
							"type": "Expression"
						},
						"fileSystem": "bronze"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ls_dl_contoso0709')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/contoso200709-WorkspaceDefaultSqlServer')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"DBName": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"connectionString": "[parameters('contoso200709-WorkspaceDefaultSqlServer_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/contoso200709-WorkspaceDefaultStorage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('contoso200709-WorkspaceDefaultStorage_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_dl_contoso0709')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('ls_dl_contoso0709_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ls_on_prem_sql_server')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "SqlServer",
				"typeProperties": {
					"server": "[parameters('ls_on_prem_sql_server_properties_typeProperties_server')]",
					"database": "[parameters('ls_on_prem_sql_server_properties_typeProperties_database')]",
					"encrypt": "mandatory",
					"trustServerCertificate": true,
					"authenticationType": "SQL",
					"userName": "[parameters('ls_on_prem_sql_server_properties_typeProperties_userName')]",
					"password": {
						"type": "SecureString",
						"value": "[parameters('ls_on_prem_sql_server_password')]"
					}
				},
				"connectVia": {
					"referenceName": "IntegrationRuntimeKhanBI",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/IntegrationRuntimeKhanBI')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutoResolveIntegrationRuntime')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 0
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/IntegrationRuntimeKhanBI')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "SelfHosted",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/WorkspaceSystemIdentity')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ManagedIdentity",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Gold_Fact_Order')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkPool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "7e7847ed-5413-46d3-a44f-4016f84cc3de"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/5fc955a9-5f26-4bec-b815-30115c8d5b68/resourceGroups/Mark_2/providers/Microsoft.Synapse/workspaces/contoso200709/bigDataPools/SparkPool",
						"name": "SparkPool",
						"type": "Spark",
						"endpoint": "https://contoso200709.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkPool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.5",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"from pyspark.sql.functions import *\n",
							"from pyspark.sql.types import *\n",
							"from delta.tables import DeltaTable\n",
							"from pyspark.sql.window import Window"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### *Incremnetal Load Date*"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"source_schema = 'silver_sales'\n",
							"\n",
							"target_schema = 'gold_sales'\n",
							"\n",
							"backdate = ''\n",
							"\n",
							"cdc_col = 'ModifiedDate'"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.FactOrder\"):\n",
							"    if len(backdate) == 0:\n",
							"        last_load_date = spark.sql(f\"\"\"\n",
							"                                SELECT MAX({cdc_col}) FROM {target_schema}.FactOrder\n",
							"                                \"\"\").collect()[0][0]\n",
							"    else:\n",
							"        last_load_date = backdate\n",
							"else:\n",
							"    last_load_date = '1900-01-01 00:00:00'\n",
							"\n",
							"last_load_date"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"source": [
							"df_src = spark.sql(f\"\"\"\n",
							"                    SELECT * FROM {source_schema}.salesorderheader \n",
							"                    WHERE {cdc_col} > '{last_load_date}'\n",
							"                    \"\"\")\n",
							"\n",
							"df_src.createOrReplaceTempView(\"src\")\n",
							"\n",
							"df_src.count()"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"source": [
							"df_fact_src = spark.sql(\"\"\"\n",
							"                Select \n",
							"                    sh.SalesOrderID,\n",
							"                    dr.DimResellerKey,\n",
							"                    drc.DimCustomerKey,\n",
							"                    dsp.DimSalesPersonKey,\n",
							"                    sh.RevisionNumber, sh.OrderDate, sh.DueDate, sh.ShipDate, sh.Status, sh.OnlineOrderFlag, sh.SalesOrderNumber,\n",
							"                    sh.PurchaseOrderNumber, sh.AccountNumber, sh.TerritoryID, sh.BillToAddressID, sh.ShipToAddressID, sh.ShipMethodID,\n",
							"                    sh.CreditCardID, sh.Subtotal, sh.TaxAmt, sh.Freight, sh.TotalDue, sh.ModifiedDate\n",
							"                FROM\n",
							"                src sh\n",
							"                LEFT JOIN gold_sales.dimreseller dr\n",
							"                    ON sh.CustomerID = dr.CustomerID\n",
							"                    AND sh.OrderDate >= dr.StartDate\n",
							"                    AND sh.OrderDate < dr.EndDate\n",
							"                LEFT JOIN gold_sales.dimretailcustomer drc\n",
							"                    ON sh.CustomerID = drc.CustomerID\n",
							"                    AND sh.OrderDate >= drc.StartDate\n",
							"                    AND sh.OrderDate < drc.EndDate\n",
							"                LEFT JOIN gold_sales.dimsalesperson dsp\n",
							"                    ON sh.SalesPersonID = dsp.SalesPersonID\n",
							"                    AND sh.OrderDate >= dsp.StartDate\n",
							"                    AND sh.OrderDate < dsp.EndDate\n",
							"                \"\"\")"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.FactOrder\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, f\"{target_schema}.FactOrder\")\n",
							"    dlt_obj.alias(\"trg\").merge(df_fact_src.alias(\"src\"), \"trg.SalesOrderID = src.SalesOrderID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=f\"src.{cdc_col} > trg.{cdc_col}\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"else:\n",
							"    df_fact_src.write.format('delta')\\\n",
							"                .mode('append')\\\n",
							"                .option('path', 'abfss://gold@dlcontoso.dfs.core.windows.net/sales/FactOrder')\\\n",
							"                .saveAsTable('gold_sales.FactOrder')"
						],
						"outputs": [],
						"execution_count": 12
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Gold_Fact_Order_Detail')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkPool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "f4d5d405-62bc-430b-af02-b02936c39750"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/5fc955a9-5f26-4bec-b815-30115c8d5b68/resourceGroups/Mark_2/providers/Microsoft.Synapse/workspaces/contoso200709/bigDataPools/SparkPool",
						"name": "SparkPool",
						"type": "Spark",
						"endpoint": "https://contoso200709.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkPool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.5",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"from pyspark.sql.functions import *\n",
							"from pyspark.sql.types import *\n",
							"from delta.tables import DeltaTable\n",
							"from pyspark.sql.window import Window"
						],
						"outputs": [],
						"execution_count": 22
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### *Incremnetal Load Date*"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"source_schema = 'silver_sales'\n",
							"\n",
							"target_schema = 'gold_sales'\n",
							"\n",
							"backdate = ''\n",
							"\n",
							"cdc_col = 'ModifiedDate'"
						],
						"outputs": [],
						"execution_count": 23
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.FactOrderDetail\"):\n",
							"    if len(backdate) == 0:\n",
							"        last_load_date = spark.sql(f\"\"\"\n",
							"                                SELECT MAX({cdc_col}) FROM {target_schema}.FactOrderDetail\n",
							"                                \"\"\").collect()[0][0]\n",
							"    else:\n",
							"        last_load_date = backdate\n",
							"else:\n",
							"    last_load_date = '1900-01-01 00:00:00'\n",
							"\n",
							"last_load_date"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"source": [
							"df_src = spark.sql(f\"\"\"\n",
							"                    SELECT * FROM {source_schema}.salesorderdetail \n",
							"                    WHERE {cdc_col} > '{last_load_date}'\n",
							"                    \"\"\")\n",
							"\n",
							"df_src.createOrReplaceTempView(\"src\")\n",
							"\n",
							"df_src.count()"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"source": [
							"df_fact_src = spark.sql(\"\"\"\n",
							"                Select \n",
							"                    sh.SalesOrderID,\n",
							"                    sh.SalesOrderDetailID,\n",
							"                    sh.CarrierTrackingNumber,\n",
							"                    sh.OrderQty,\n",
							"                    dp.DimProductKey,\n",
							"                    sh.SpecialOfferID, sh.UnitPrice, sh.UnitPriceDiscount, sh.LineTotal, sh.ModifiedDate\n",
							"                FROM\n",
							"                src sh\n",
							"                LEFT JOIN gold_sales.dimproduct dp\n",
							"                    ON sh.ProductID = dp.ProductID\n",
							"                    AND sh.ModifiedDate >= dp.StartDate\n",
							"                    AND sh.ModifiedDate < dp.EndDate\n",
							"                \"\"\")"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.FactOrderDetail\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, f\"{target_schema}.FactOrderDetail\")\n",
							"    dlt_obj.alias(\"trg\").merge(df_fact_src.alias(\"src\"), \"trg.SalesOrderID = src.SalesOrderID AND trg.SalesOrderDetailID = src.SalesOrderDetailID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=f\"src.{cdc_col} > trg.{cdc_col}\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"else:\n",
							"    df_fact_src.write.format('delta')\\\n",
							"                .mode('append')\\\n",
							"                .option('path', 'abfss://gold@dlcontoso.dfs.core.windows.net/sales/FactOrderDetail')\\\n",
							"                .saveAsTable('gold_sales.FactOrderDetail')"
						],
						"outputs": [],
						"execution_count": 27
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Gold_Product')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkPool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "481096f9-81fe-43fd-9807-b8b71f95c1b8"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/5fc955a9-5f26-4bec-b815-30115c8d5b68/resourceGroups/Mark_2/providers/Microsoft.Synapse/workspaces/contoso200709/bigDataPools/SparkPool",
						"name": "SparkPool",
						"type": "Spark",
						"endpoint": "https://contoso200709.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkPool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.5",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"from pyspark.sql.functions import *\n",
							"from pyspark.sql.types import *\n",
							"from delta.tables import DeltaTable\n",
							"from pyspark.sql.window import Window\n",
							""
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "code",
						"source": [
							"source_schema = 'silver_sales'\n",
							"\n",
							"target_schema = 'gold_sales'\n",
							"\n",
							"surrogate_Key = 'DimProductKey'\n",
							"\n",
							"key_col = 'ProductID'"
						],
						"outputs": [],
						"execution_count": 32
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"df_src = spark.sql(f\"\"\"\n",
							"\t\t\t\t\tSELECT\n",
							"\t\t\t\t\t\tP.ProductID, P.`Name` AS ProductName, P.ProductNumber, P.MakeFlag, P.FinishedGoodsFlag,\n",
							"\t\t\t\t\t\tP.Color, P.SafetyStockLevel, P.ReorderPoint, P.StandardCost, P.ListPrice, P.Size,\n",
							"\t\t\t\t\t\tP.SizeUnitMeasureCode, P.WeightUnitMeasureCode, P.`Weight`, P.DaysToManufacture,\n",
							"\t\t\t\t\t\tP.ProductLine, P.Class, P.Style, P.ProductModelID, \n",
							"\t\t\t\t\t\tP.SellStartDate, P.SellEndDate, P.DiscontinuedDate, P.ProductSubcategoryID,\n",
							"\t\t\t\t\t\tPS.`Name` AS ProductSubcategory, PS.ProductCategoryID, PC.`Name` AS ProductCategory,\n",
							"\t\t\t\t\t\tCURRENT_TIMESTAMP() AS StartDate,\n",
							"                    \tCAST('3000-12-31 00:00:00' AS TIMESTAMP) AS EndDate,\n",
							"                    \t'Y' AS IsCurrent\n",
							"\t\t\t\t\tFROM silver_sales.`Product` P\n",
							"\t\t\t\t\tLEFT JOIN silver_sales.ProductSubcategory PS\n",
							"\t\t\t\t\tON P.ProductSubcategoryID = PS.ProductSubcategoryID\n",
							"\t\t\t\t\tLEFT JOIN silver_sales.ProductCategory PC\n",
							"\t\t\t\t\tON PS.ProductCategoryID = PC.ProductCategoryID\n",
							"\t\t\t\t\"\"\")"
						],
						"outputs": [],
						"execution_count": 33
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"if spark.catalog.tableExists(F\"{target_schema}.DimProduct\"):\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT {key_col}, {surrogate_Key}, CreatedAt, UpdatedAt\n",
							"                    FROM {target_schema}.DimProduct\n",
							"                    \"\"\")\n",
							"\n",
							"else:\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT \n",
							"                    CAST('0' AS INT) AS {key_col}, \n",
							"                    CAST('0' AS INT) AS {surrogate_Key}, \n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS CreatedAt,\n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS UpdatedAt\n",
							"                    WHERE 1=0\n",
							"                    \"\"\")"
						],
						"outputs": [],
						"execution_count": 34
					},
					{
						"cell_type": "code",
						"source": [
							"df_src.createOrReplaceTempView(\"src\")\n",
							"df_trg.createOrReplaceTempView(\"trg\")\n",
							"\n",
							"df_join = spark.sql(f\"\"\"\n",
							"                SELECT \n",
							"                src.*,\n",
							"                trg.{surrogate_Key},\n",
							"                trg.CreatedAt,\n",
							"                trg.UpdatedAt\n",
							"                FROM\n",
							"                src LEFT JOIN trg\n",
							"                ON src.{key_col} = trg.{key_col}\n",
							"            \"\"\")"
						],
						"outputs": [],
						"execution_count": 35
					},
					{
						"cell_type": "code",
						"source": [
							"df_old = df_join.filter(col(f\"{surrogate_Key}\").isNotNull())\n",
							"\n",
							"df_new = df_join.filter(col(f\"{surrogate_Key}\").isNull())"
						],
						"outputs": [],
						"execution_count": 36
					},
					{
						"cell_type": "code",
						"source": [
							"df_old_enr = df_old.withColumn(\"UpdatedAt\", current_timestamp())"
						],
						"outputs": [],
						"execution_count": 37
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(F\"{target_schema}.DimProduct\"):\n",
							"    max_surrogate_key = spark.sql(f\"\"\"\n",
							"                        SELECT MAX({surrogate_Key}) from {target_schema}.DimProduct\n",
							"                        \"\"\").collect()[0][0]\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_Key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"\n",
							"else:\n",
							"    max_surrogate_key = 0\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_Key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"\n",
							"max_surrogate_key"
						],
						"outputs": [],
						"execution_count": 38
					},
					{
						"cell_type": "code",
						"source": [
							"df_union = df_old_enr.unionByName(df_new_enr)\n",
							"\n",
							"df_union.createOrReplaceTempView(\"df_final\")"
						],
						"outputs": [],
						"execution_count": 39
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.DimProduct\"):\n",
							"    spark.sql(F\"\"\"\n",
							"            MERGE INTO {target_schema}.DimProduct AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_Key} = src.{surrogate_Key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"\n",
							"            WHEN MATCHED AND (\n",
							"                trg.MakeFlag <> src.MakeFlag OR\n",
							"                trg.ProductName <> src.ProductName OR\n",
							"                trg.ProductNumber <> src.ProductNumber OR\n",
							"                trg.FinishedGoodsFlag <> src.FinishedGoodsFlag OR\n",
							"                trg.Color <> src.Color OR\n",
							"                trg.SafetyStockLevel <> src.SafetyStockLevel OR\n",
							"                trg.ReorderPoint <> src.ReorderPoint OR\n",
							"                trg.StandardCost <> src.StandardCost OR\n",
							"                trg.ListPrice <> src.ListPrice OR\n",
							"                trg.Size <> src.Size OR\n",
							"                trg.SizeUnitMeasureCode <> src.SizeUnitMeasureCode OR\n",
							"                trg.WeightUnitMeasureCode <> src.WeightUnitMeasureCode OR\n",
							"                trg.Weight <> src.Weight OR\n",
							"                trg.DaysToManufacture <> src.DaysToManufacture OR\n",
							"                trg.ProductLine <> src.ProductLine OR\n",
							"                trg.Class <> src.Class OR\n",
							"                trg.Style <> src.Style OR\n",
							"                trg.ProductModelID <> src.ProductModelID OR\n",
							"                trg.ProductSubcategory <> src.ProductSubcategory OR\n",
							"                trg.ProductCategory <> src.ProductCategory\n",
							"            )\n",
							"            THEN UPDATE SET\n",
							"                trg.IsCurrent = 'N',\n",
							"                trg.EndDate = Current_Timestamp();\n",
							"    \"\"\")\n",
							"\n",
							"    spark.sql(f\"\"\"\n",
							"            MERGE INTO {target_schema}.DimProduct AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_Key} = src.{surrogate_Key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"            WHEN NOT MATCHED THEN INSERT *\n",
							"\n",
							"    \"\"\")\n",
							"\n",
							"else:\n",
							"    df_union.write.format(\"delta\")\\\n",
							"                    .mode(\"append\")\\\n",
							"                    .option(\"path\", \"abfss://gold@dlcontoso.dfs.core.windows.net/sales/DimProduct\")\\\n",
							"                    .saveAsTable(f\"{target_schema}.DimProduct\")"
						],
						"outputs": [],
						"execution_count": 40
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Gold_Reseller')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkPool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "0cd67938-cba8-4311-adbe-dc1df1f90fe7"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/5fc955a9-5f26-4bec-b815-30115c8d5b68/resourceGroups/Mark_2/providers/Microsoft.Synapse/workspaces/contoso200709/bigDataPools/SparkPool",
						"name": "SparkPool",
						"type": "Spark",
						"endpoint": "https://contoso200709.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkPool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.5",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"from pyspark.sql.functions import *\n",
							"from pyspark.sql.types import *\n",
							"from delta.tables import DeltaTable\n",
							"from pyspark.sql.window import Window\n",
							""
						],
						"outputs": [],
						"execution_count": 41
					},
					{
						"cell_type": "code",
						"source": [
							"source_schema = 'silver_sales'\n",
							"\n",
							"target_schema = 'gold_sales'\n",
							"\n",
							"surrogate_Key = 'DimResellerKey'\n",
							"\n",
							"key_col = 'CustomerID'"
						],
						"outputs": [],
						"execution_count": 42
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"df_src = spark.sql(f\"\"\"\n",
							"SELECT \n",
							"\tc.CustomerID, c.PersonID, c.StoreID, c.AccountNumber,\n",
							"\tsto.`Name` as StoreName, sto.SalesPersonID,\n",
							"\ta.AddressLine1, a.City, a.PostalCode, \n",
							"\tsp.`Name` as StateProvinceName, sp.StateProvinceCode, \n",
							"\tcr.`Name` as CountryName, st.CountryRegionCode as CountryCode,\n",
							"\tst.`Name` as Territory, st.`Group`,\n",
							"\tadt.`Name` as AddressType,\n",
							"\tp.PersonType, p.Title, p.FirstName, p.MiddleName, p.LastName,\n",
							"\tpp.PhoneNumber,\n",
							"\tpnt.`Name` as PhoneNumberType,\n",
							"\tCURRENT_TIMESTAMP() AS StartDate,\n",
							"    CAST('3000-12-31 00:00:00' AS TIMESTAMP) AS EndDate,\n",
							"    'Y' AS IsCurrent\n",
							"FROM silver_sales.reseller c\n",
							"LEFT JOIN silver_sales.BusinessEntityAddress bea\n",
							"ON c.StoreID = bea.BusinessEntityID AND bea.AddressTypeID = 3\n",
							"LEFT JOIN silver_sales.Address a\n",
							"ON bea.AddressID = a.AddressID\n",
							"LEFT JOIN silver_sales.StateProvince sp\n",
							"ON a.StateProvinceID = sp.StateProvinceID\n",
							"LEFT JOIN silver_sales.SalesTerritory st\n",
							"ON sp.TerritoryID = st.TerritoryID\n",
							"LEFT JOIN silver_sales.CountryRegion cr\n",
							"ON st.CountryRegionCode = cr.CountryRegionCode\n",
							"LEFT JOIN silver_sales.AddressType adt\n",
							"ON bea.AddressTypeID = adt.AddressTypeID\n",
							"LEFT JOIN silver_sales.Person p\n",
							"ON c.PersonID = p.BusinessEntityID\n",
							"LEFT JOIN silver_sales.PersonPhone pp\n",
							"ON p.BusinessEntityID = pp.BusinessEntityID\n",
							"LEFT JOIN silver_sales.PhoneNumberType pnt\n",
							"ON pp.PhoneNumberTypeID = pnt.PhoneNumberTypeID AND pnt.`Name` = 'Work'\n",
							"LEFT JOIN silver_sales.Store sto\n",
							"ON c.StoreID = sto.BusinessEntityID\n",
							"WHERE StoreID IS NOT NULL\n",
							"\"\"\")"
						],
						"outputs": [],
						"execution_count": 43
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"if spark.catalog.tableExists(F\"{target_schema}.DimReseller\"):\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT {key_col}, {surrogate_Key}, CreatedAt, UpdatedAt\n",
							"                    FROM {target_schema}.DimReseller\n",
							"                    \"\"\")\n",
							"\n",
							"else:\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT \n",
							"                    CAST('0' AS INT) AS {key_col}, \n",
							"                    CAST('0' AS INT) AS {surrogate_Key}, \n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS CreatedAt,\n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS UpdatedAt\n",
							"                    WHERE 1=0\n",
							"                    \"\"\")"
						],
						"outputs": [],
						"execution_count": 44
					},
					{
						"cell_type": "code",
						"source": [
							"df_src.createOrReplaceTempView(\"src\")\n",
							"df_trg.createOrReplaceTempView(\"trg\")\n",
							"\n",
							"df_join = spark.sql(f\"\"\"\n",
							"                SELECT \n",
							"                src.*,\n",
							"                trg.{surrogate_Key},\n",
							"                trg.CreatedAt,\n",
							"                trg.UpdatedAt\n",
							"                FROM\n",
							"                src LEFT JOIN trg\n",
							"                ON src.{key_col} = trg.{key_col}\n",
							"            \"\"\")"
						],
						"outputs": [],
						"execution_count": 45
					},
					{
						"cell_type": "code",
						"source": [
							"df_old = df_join.filter(col(f\"{surrogate_Key}\").isNotNull())\n",
							"\n",
							"df_new = df_join.filter(col(f\"{surrogate_Key}\").isNull())"
						],
						"outputs": [],
						"execution_count": 46
					},
					{
						"cell_type": "code",
						"source": [
							"df_old_enr = df_old.withColumn(\"UpdatedAt\", current_timestamp())"
						],
						"outputs": [],
						"execution_count": 47
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(F\"{target_schema}.DimReseller\"):\n",
							"    max_surrogate_key = spark.sql(f\"\"\"\n",
							"                        SELECT MAX({surrogate_Key}) from {target_schema}.DimReseller\n",
							"                        \"\"\").collect()[0][0]\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_Key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"\n",
							"else:\n",
							"    max_surrogate_key = 0\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_Key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"\n",
							"max_surrogate_key"
						],
						"outputs": [],
						"execution_count": 48
					},
					{
						"cell_type": "code",
						"source": [
							"df_union = df_old_enr.unionByName(df_new_enr)\n",
							"\n",
							"df_union.createOrReplaceTempView(\"df_final\")"
						],
						"outputs": [],
						"execution_count": 49
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.DimReseller\"):\n",
							"    spark.sql(F\"\"\"\n",
							"            MERGE INTO {target_schema}.DimReseller AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_Key} = src.{surrogate_Key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"\n",
							"            WHEN MATCHED AND (\n",
							"                trg.PersonID <> src.PersonID OR\n",
							"                trg.StoreID <> src.StoreID OR\n",
							"                trg.AccountNumber <> src.AccountNumber OR\n",
							"                trg.StoreName <> src.StoreName OR\n",
							"                trg.SalesPersonID <> src.SalesPersonID OR\n",
							"                trg.AddressLine1 <> src.AddressLine1 OR\n",
							"                trg.City <> src.City OR\n",
							"                trg.PostalCode <> src.PostalCode OR\n",
							"                trg.StateProvinceName <> src.StateProvinceName OR\n",
							"                trg.StateProvinceCode <> src.StateProvinceCode OR\n",
							"                trg.CountryName <> src.CountryName OR\n",
							"                trg.CountryCode <> src.CountryCode OR\n",
							"                trg.Territory <> src.Territory OR\n",
							"                trg.Group <> src.Group OR\n",
							"                trg.FirstName <> src.FirstName OR\n",
							"                trg.MiddleName <> src.MiddleName OR\n",
							"                trg.LastName <> src.LastName OR\n",
							"                trg.PhoneNumber <> src.PhoneNumber OR\n",
							"                trg.PhoneNumberType <> src.PhoneNumberType\n",
							"            )\n",
							"            THEN UPDATE SET\n",
							"                trg.IsCurrent = 'N',\n",
							"                trg.EndDate = Current_Timestamp();\n",
							"    \"\"\")\n",
							"\n",
							"    spark.sql(f\"\"\"\n",
							"            MERGE INTO {target_schema}.DimReseller AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_Key} = src.{surrogate_Key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"            WHEN NOT MATCHED THEN INSERT *\n",
							"\n",
							"    \"\"\")\n",
							"\n",
							"else:\n",
							"    df_union.write.format(\"delta\")\\\n",
							"                    .mode(\"append\")\\\n",
							"                    .option(\"path\", \"abfss://gold@dlcontoso.dfs.core.windows.net/sales/DimReseller\")\\\n",
							"                    .saveAsTable(f\"{target_schema}.DimReseller\")"
						],
						"outputs": [],
						"execution_count": 50
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Gold_Retail_Customer')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkPool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "6dbac1d1-b248-4fb4-a2a9-9a6bf37ebb89"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/5fc955a9-5f26-4bec-b815-30115c8d5b68/resourceGroups/Mark_2/providers/Microsoft.Synapse/workspaces/contoso200709/bigDataPools/SparkPool",
						"name": "SparkPool",
						"type": "Spark",
						"endpoint": "https://contoso200709.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkPool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.5",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"from pyspark.sql.functions import *\n",
							"from pyspark.sql.types import *\n",
							"from delta.tables import DeltaTable\n",
							"from pyspark.sql.window import Window\n",
							""
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"source": [
							"source_schema = 'silver_sales'\n",
							"\n",
							"target_schema = 'gold_sales'\n",
							"\n",
							"surrogate_Key = 'DimCustomerKey'\n",
							"\n",
							"key_col = 'CustomerID'"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"df_src = spark.sql(f\"\"\"\n",
							"SELECT \n",
							"\tc.CustomerID, c.PersonID, c.AccountNumber,\n",
							"\tp.PersonType, p.Title, p.FirstName, p.MiddleName, p.LastName, p.EmailPromotion,\n",
							"\tad.AddressLine1, ad.City, ad.PostalCode,\n",
							"\tadt.`Name` AS AddressType,\n",
							"\tst.StateProvinceCode, st.`Name` AS StateProvinceName, st.IsOnlyStateProvinceFlag,\n",
							"\tter.CountryRegionCode AS CountryCode, ter.`Name` AS CountryName, ter.`Group`,\n",
							"\tpp.PhoneNumber, pnt.`Name` AS PhoneNumberType,\n",
							"\teml.EmailAddress,\n",
							"\tCURRENT_TIMESTAMP() as StartDate,\n",
							"    CAST('3000-12-31' AS TIMESTAMP) as EndDate,\n",
							"    'Y' as IsCurrent\n",
							"FROM \n",
							"{source_schema}.retailcustomer c\n",
							"LEFT JOIN {source_schema}.Person p\n",
							"ON c.PersonID = p.BusinessEntityID\n",
							"LEFT JOIN {source_schema}.BusinessEntityAddress as bea\n",
							"ON c.PersonID = bea.BusinessEntityID\n",
							"LEFT JOIN {source_schema}.Address as ad\n",
							"ON bea.AddressID = ad.AddressID\n",
							"LEFT JOIN {source_schema}.AddressType as adt\n",
							"ON bea.AddressTypeID = adt.AddressTypeID\n",
							"LEFT JOIN {source_schema}.StateProvince st\n",
							"ON ad.StateProvinceID = st.StateProvinceID\n",
							"LEFT JOIN {source_schema}.CountryRegion cr\n",
							"ON st.CountryRegionCode = cr.CountryRegionCode\n",
							"LEFT JOIN {source_schema}.SalesTerritory ter\n",
							"ON st.TerritoryID = ter.TerritoryID\n",
							"LEFT JOIN {source_schema}.PersonPhone pp\n",
							"ON p.BusinessEntityID = pp.BusinessEntityID\n",
							"LEFT JOIN {source_schema}.PhoneNumberType pnt\n",
							"ON pp.PhoneNumberTypeID = pnt.PhoneNumberTypeID\n",
							"LEFT JOIN {source_schema}.EmailAddress eml\n",
							"ON p.BusinessEntityID = eml.BusinessEntityID\n",
							"WHERE StoreID IS NUlL AND adt.`Name` = 'Home'\n",
							"ORDER BY CustomerID\n",
							"\"\"\")"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"if spark.catalog.tableExists(F\"{target_schema}.DimRetailCustomer\"):\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT {key_col}, {surrogate_Key}, CreatedAt, UpdatedAt\n",
							"                    FROM {target_schema}.DimRetailCustomer\n",
							"                    \"\"\")\n",
							"\n",
							"else:\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT \n",
							"                    CAST('0' AS INT) AS {key_col}, \n",
							"                    CAST('0' AS INT) AS {surrogate_Key}, \n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS CreatedAt,\n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS UpdatedAt\n",
							"                    WHERE 1=0\n",
							"                    \"\"\")"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"source": [
							"df_src.createOrReplaceTempView(\"src\")\n",
							"df_trg.createOrReplaceTempView(\"trg\")\n",
							"\n",
							"df_join = spark.sql(f\"\"\"\n",
							"                SELECT \n",
							"                src.*,\n",
							"                trg.{surrogate_Key},\n",
							"                trg.CreatedAt,\n",
							"                trg.UpdatedAt\n",
							"                FROM\n",
							"                src LEFT JOIN trg\n",
							"                ON src.{key_col} = trg.{key_col}\n",
							"            \"\"\")"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"source": [
							"df_old = df_join.filter(col(f\"{surrogate_Key}\").isNotNull())\n",
							"\n",
							"df_new = df_join.filter(col(f\"{surrogate_Key}\").isNull())"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"source": [
							"df_old_enr = df_old.withColumn(\"UpdatedAt\", current_timestamp())"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(F\"{target_schema}.DimRetailCustomer\"):\n",
							"    max_surrogate_key = spark.sql(f\"\"\"\n",
							"                        SELECT MAX({surrogate_Key}) from {target_schema}.DimRetailCustomer\n",
							"                        \"\"\").collect()[0][0]\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_Key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"\n",
							"else:\n",
							"    max_surrogate_key = 0\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_Key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"\n",
							"max_surrogate_key"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"source": [
							"df_union = df_old_enr.unionByName(df_new_enr)\n",
							"\n",
							"df_union.createOrReplaceTempView(\"df_final\")"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.DimRetailCustomer\"):\n",
							"    spark.sql(F\"\"\"\n",
							"            MERGE INTO {target_schema}.DimRetailCustomer AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_Key} = src.{surrogate_Key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"\n",
							"            WHEN MATCHED AND (\n",
							"                trg.PersonID <> src.PersonID OR\n",
							"                trg.EmailAddress <> src.EmailAddress OR\n",
							"                trg.AddressLine1 <> src.AddressLine1 OR\n",
							"                trg.City <> src.City OR\n",
							"                trg.PostalCode <> src.PostalCode OR\n",
							"                trg.PersonType <> src.PersonType OR\n",
							"                trg.FirstName <> src.FirstName OR\n",
							"                trg.MiddleName <> src.MiddleName OR\n",
							"                trg.LastName <> src.LastName OR\n",
							"                trg.PhoneNumber <> src.PhoneNumber OR\n",
							"                trg.PhoneNumberType <> src.PhoneNumberType\n",
							"            )\n",
							"            THEN UPDATE SET\n",
							"                trg.IsCurrent = 'N',\n",
							"                trg.EndDate = Current_Timestamp();\n",
							"    \"\"\")\n",
							"\n",
							"    spark.sql(f\"\"\"\n",
							"            MERGE INTO {target_schema}.DimRetailCustomer AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_Key} = src.{surrogate_Key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"            WHEN NOT MATCHED THEN INSERT *\n",
							"\n",
							"    \"\"\")\n",
							"\n",
							"else:\n",
							"    df_union.write.format(\"delta\")\\\n",
							"                    .mode(\"append\")\\\n",
							"                    .option(\"path\", \"abfss://gold@dlcontoso.dfs.core.windows.net/sales/DimRetailCustomer\")\\\n",
							"                    .saveAsTable(f\"{target_schema}.DimRetailCustomer\")"
						],
						"outputs": [],
						"execution_count": 11
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Gold_Sales_Person')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkPool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "cd83a1f3-23b2-4bf7-8229-46906ec40ebe"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/5fc955a9-5f26-4bec-b815-30115c8d5b68/resourceGroups/Mark_2/providers/Microsoft.Synapse/workspaces/contoso200709/bigDataPools/SparkPool",
						"name": "SparkPool",
						"type": "Spark",
						"endpoint": "https://contoso200709.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkPool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.5",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"from pyspark.sql.functions import *\n",
							"from pyspark.sql.types import *\n",
							"from delta.tables import DeltaTable\n",
							"from pyspark.sql.window import Window"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"source": [
							"source_schema = 'silver_sales'\n",
							"\n",
							"target_schema = 'gold_sales'\n",
							"\n",
							"surrogate_key = 'DimSalesPersonKey'\n",
							"\n",
							"key_col = 'SalesPersonID'"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"source": [
							"df_src = spark.sql(f\"\"\"\n",
							"                SELECT\n",
							"                    sp.BusinessEntityID AS SalesPersonID,\n",
							"                    p.PersonType, p.Title, p.FirstName, p.MiddleName, p.LastName,\n",
							"                    p.EmailPromotion, pp.PhoneNumber, pnt.`Name` AS PhoneNumberType,\n",
							"                    ed.EmailAddress,\n",
							"                    sp.SalesQuota,\n",
							"                    st.`Name` AS TerritoryName,\n",
							"                    CURRENT_TIMESTAMP() AS StartDate,\n",
							"                    CAST('3000-12-31 00:00:00' AS TIMESTAMP) AS EndDate,\n",
							"                    'Y' AS IsCurrent\n",
							"                FROM {source_schema}.SalesPerson sp\n",
							"                LEFT JOIN {source_schema}.Person p\n",
							"                On sp.BusinessEntityID = p.BusinessEntityID\n",
							"                LEFT JOIN {source_schema}.PersonPhone pp\n",
							"                ON pp.BusinessEntityID = p.BusinessEntityID\n",
							"                LEFT JOIN {source_schema}.EmailAddress ed\n",
							"                ON ed.BusinessEntityID = p.BusinessEntityID\n",
							"                LEFT JOIN {source_schema}.PhoneNumberType pnt\n",
							"                ON pp.PhoneNumberTypeID = pnt.PhoneNumberTypeID\n",
							"                LEFT JOIN {source_schema}.SalesTerritory st\n",
							"                ON sp.TerritoryID = st.TerritoryID\n",
							"                \"\"\")"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.DimSalesPerson\"):\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT {key_col}, {surrogate_key}, CreatedAt, UpdatedAt \n",
							"                    FROM {target_schema}.DimSalesPerson\n",
							"                    \"\"\")\n",
							"else:\n",
							"    df_trg = spark.sql(f\"\"\"\n",
							"                    SELECT \n",
							"                    CAST('0' AS INT) AS {key_col}, \n",
							"                    CAST('0' AS INT) AS {surrogate_key}, \n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS CreatedAt,\n",
							"                    CAST('1900-01-01 00:00:00' AS TIMESTAMP) AS UpdatedAt\n",
							"                    WHERE 1=0\n",
							"                    \"\"\")"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"source": [
							"df_src.createOrReplaceTempView(\"src\")\n",
							"\n",
							"df_trg.createOrReplaceTempView(\"trg\")\n",
							"\n",
							"df_join = spark.sql(f\"\"\"\n",
							"                SELECT \n",
							"                    src.*,\n",
							"                    trg.{surrogate_key}, trg.CreatedAt, trg.UpdatedAt\n",
							"                FROM\n",
							"                src\n",
							"                LEFT JOIN\n",
							"                trg\n",
							"                ON src.{key_col} = trg.{key_col}\n",
							"                \"\"\")"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"source": [
							"df_old = df_join.filter(col(f\"{surrogate_key}\").isNotNull())\n",
							"\n",
							"df_new = df_join.filter(col(f\"{surrogate_key}\").isNull())"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"source": [
							"df_old_enr = df_old.withColumn(\"UpdatedAt\", current_timestamp())"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.DimSalesPerson\"):\n",
							"    max_surrogate_key = spark.sql(f\"\"\"\n",
							"                        SELECT MAX({surrogate_key}) FROM {target_schema}.DimSalesPerson\n",
							"                        \"\"\").collect()[0][0]\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"else:\n",
							"    max_surrogate_key = 0\n",
							"    w = Window.orderBy(monotonically_increasing_id())\n",
							"    df_new_enr = df_new.withColumn(f\"{surrogate_key}\", row_number().over(w) + lit(max_surrogate_key))\\\n",
							"                        .withColumn(\"CreatedAt\", current_timestamp())\\\n",
							"                        .withColumn(\"UpdatedAt\", current_timestamp())\n",
							"max_surrogate_key"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"df_union = df_old_enr.unionByName(df_new_enr)\n",
							"\n",
							"df_union.createOrReplaceTempView(\"df_final\")"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(f\"{target_schema}.DimSalesPerson\"):\n",
							"    spark.sql(F\"\"\"\n",
							"            MERGE INTO {target_schema}.DimSalesPerson AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_key} = src.{surrogate_key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"\n",
							"            WHEN MATCHED AND (\n",
							"                trg.PersonType <> src.PersonType OR\n",
							"                trg.FirstName <> src.FirstName OR\n",
							"                trg.MiddleName <> src.MiddleName OR\n",
							"                trg.LastName <> src.LastName OR\n",
							"                trg.PhoneNumber <> src.PhoneNumber OR\n",
							"                trg.PhoneNumberType <> src.PhoneNumberType OR\n",
							"                trg.EmailAddress <> src.EmailAddress OR\n",
							"                trg.TerritoryName <> src.TerritoryName OR\n",
							"                trg.SalesQuota <> src.SalesQuota\n",
							"            )\n",
							"            THEN UPDATE SET\n",
							"                trg.IsCurrent = 'N',\n",
							"                trg.EndDate = Current_Timestamp();\n",
							"    \"\"\")\n",
							"\n",
							"    spark.sql(f\"\"\"\n",
							"            MERGE INTO {target_schema}.DimSalesPerson AS trg\n",
							"            USING df_final AS src\n",
							"            ON trg.{surrogate_key} = src.{surrogate_key}\n",
							"            AND trg.IsCurrent = 'Y'\n",
							"            WHEN NOT MATCHED THEN INSERT *\n",
							"\n",
							"    \"\"\")\n",
							"\n",
							"else:\n",
							"    df_union.write.format(\"delta\")\\\n",
							"                    .mode(\"append\")\\\n",
							"                    .option(\"path\", \"abfss://gold@dlcontoso.dfs.core.windows.net/sales/DimSalesPerson\")\\\n",
							"                    .saveAsTable(f\"{target_schema}.DimSalesPerson\")"
						],
						"outputs": [],
						"execution_count": 10
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Silver')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "SparkPool",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "3245d359-8d56-4557-b127-bb018c538a3f"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/5fc955a9-5f26-4bec-b815-30115c8d5b68/resourceGroups/Mark_2/providers/Microsoft.Synapse/workspaces/contoso200709/bigDataPools/SparkPool",
						"name": "SparkPool",
						"type": "Spark",
						"endpoint": "https://contoso200709.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/SparkPool",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net",
							"authHeader": null
						},
						"sparkVersion": "3.5",
						"nodeCount": 10,
						"cores": 4,
						"memory": 28,
						"extraHeader": null
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# *Silver Sales Tables Transformations*"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"from pyspark.sql.functions import *\n",
							"from pyspark.sql.types import *\n",
							"from delta.tables import DeltaTable"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Sales Header"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/sales/SalesOrderHeader\")"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = df.drop(col(\"CreditCardApprovalCode\"), col(\"CurrencyRateID\"), col(\"Comment\"), col(\"rowguid\"))"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(\"Silver_Sales.SalesOrderHeader\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"Silver_Sales.SalesOrderHeader\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.SalesOrderID = src.SalesOrderID\")\\\n",
							"            .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"            .whenNotMatchedInsertAll()\\\n",
							"            .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/SalesOrderHeader\")\\\n",
							"            .saveAsTable(\"Silver_Sales.SalesOrderHeader\")"
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Sales Details"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/sales/SalesOrderDetail\")"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = df.drop(col(\"rowguid\"))"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"if spark.catalog.tableExists(\"silver_sales.SalesOrderDetail\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.SalesOrderDetail\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.SalesOrderID = src.SalesOrderID AND trg.SalesOrderDetailID = src.SalesOrderDetailID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/SalesOrderDetail\")\\\n",
							"            .saveAsTable(\"silver_sales.SalesOrderDetail\")"
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Customers"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/sales/Customer')"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"df_reseller = df.filter(col(\"StoreID\").isNotNull())\n",
							"df_reseller = df_reseller.drop(col(\"rowguid\"))"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"df_retailCust = df.filter(col(\"StoreID\").isNull())\n",
							"df_retailCust = df_retailCust.drop(col(\"rowguid\"))"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(\"silver_sales.Reseller\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.Reseller\")\n",
							"    dlt_obj.alias(\"trg\").merge(df_reseller.alias(\"src\"), \"trg.CustomerID = src.CustomerID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df_reseller.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/Reseller\")\\\n",
							"            .saveAsTable(\"silver_sales.Reseller\")"
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"if spark.catalog.tableExists(\"silver_sales.RetailCustomer\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.RetailCustomer\")\n",
							"    dlt_obj.alias(\"trg\").merge(df_retailCust.alias(\"src\"), \"trg.CustomerID = src.CustomerID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df_reseller.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/RetailCustomer\")\\\n",
							"            .saveAsTable(\"silver_sales.RetailCustomer\")"
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### BusinessEntityAddress"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/person/BusinessEntityAddress')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.BusinessEntityAddress\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.BusinessEntityAddress\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.BusinessEntityID = src.BusinessEntityID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/BusinessEntityAddress\")\\\n",
							"        .saveAsTable(\"silver_sales.BusinessEntityAddress\")\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/person/vw_Address_Clean')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"), col(\"AddressLine2\"), col(\"SpatialLocation\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.Address\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.Address\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.AddressID = src.AddressID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/Address\")\\\n",
							"        .saveAsTable(\"silver_sales.Address\")\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/person/AddressType')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.AddressType\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.AddressType\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.AddressTypeID = src.AddressTypeID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/AddressType\")\\\n",
							"        .saveAsTable(\"silver_sales.AddressType\")\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/person/StateProvince')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.StateProvince\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.StateProvince\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.StateProvinceID = src.StateProvinceID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/StateProvince\")\\\n",
							"        .saveAsTable(\"silver_sales.StateProvince\")\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/person/CountryRegion')\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.CountryRegion\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.CountryRegion\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.CountryRegionCode = src.CountryRegionCode\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/CountryRegion\")\\\n",
							"        .saveAsTable(\"silver_sales.CountryRegion\")\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/sales/SalesTerritory')\n",
							"\n",
							"df = df.drop(col(\"SalesYTD\"), col(\"SalesLastYear\"), col(\"CostYTD\"), col(\"CostLastYear\"), col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.SalesTerritory\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.SalesTerritory\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.TerritoryID = src.TerritoryID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/SalesTerritory\")\\\n",
							"        .saveAsTable(\"silver_sales.SalesTerritory\")\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/person/EmailAddress')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.EmailAddress\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.EmailAddress\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.BusinessEntityID = src.BusinessEntityID AND trg.EmailAddressID = src.EmailAddressID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/EmailAddress\")\\\n",
							"        .saveAsTable(\"silver_sales.EmailAddress\")\n",
							""
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Store"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/sales/Store')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"), col(\"Demographics\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.Store\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.Store\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.BusinessEntityID = src.BusinessEntityID\")\\\n",
							"                .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                .whenNotMatchedInsertAll()\\\n",
							"                .execute()\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"        .mode(\"append\")\\\n",
							"        .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/Store\")\\\n",
							"        .saveAsTable(\"silver_sales.Store\")\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### SalesReason"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/sales/SalesOrderHeaderSalesReason\")\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.OrderSalesReason\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.OrderSalesReason\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.SalesOrderID = src.SalesOrderID AND trg.SalesReasonID = src.SalesReasonID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/OrderSalesReason\")\\\n",
							"            .saveAsTable(\"silver_sales.OrderSalesReason\")            "
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/sales/SalesReason\")\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.SalesReason\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.SalesReason\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.SalesReasonID = src.SalesReasonID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/SalesReason\")\\\n",
							"            .saveAsTable(\"silver_sales.SalesReason\")            "
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Special Offer"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/sales/SpecialOffer\")\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.SpecialOffer\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.SpecialOffer\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.SpecialOfferID = src.SpecialOfferID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/SpecialOffer\")\\\n",
							"            .saveAsTable(\"silver_sales.SpecialOffer\")            "
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Perosn"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/person/Person\")\n",
							"\n",
							"df = df.drop(col(\"rowguid\"), col(\"AdditionalContactInfo\"), col(\"Demographics\"), col(\"Suffix\"))\n",
							"\n",
							"\n",
							"df = df.withColumn(\"PersonType\", when(col(\"PersonType\") == \"IN\", \"Individual Retail Customer\")\\\n",
							"                            .when(col(\"PersonType\") == \"SC\", \"Store Contact\")\\\n",
							"                            .when(col(\"PersonType\") == \"EM\", \"Employee\")\\\n",
							"                            .when(col(\"PersonType\") == \"SP\", \"Sales Person\")\\\n",
							"                            .when(col(\"PersonType\") == \"VC\", \"Vendor Contact\")\\\n",
							"                            .when(col(\"PersonType\") == \"GC\", \"General Contact\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.Person\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.Person\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.BusinessEntityID = src.BusinessEntityID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/Person\")\\\n",
							"            .saveAsTable(\"silver_sales.Person\")            "
						],
						"outputs": [],
						"execution_count": 18
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/person/PersonPhone\")\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.PersonPhone\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.PersonPhone\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.BusinessEntityID = src.BusinessEntityID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/PersonPhone\")\\\n",
							"            .saveAsTable(\"silver_sales.PersonPhone\")            "
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/person/PhoneNumberType\")\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.PhoneNumberType\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.PhoneNumberType\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.PhoneNumberTypeID = src.PhoneNumberTypeID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/person/PhoneNumberType\")\\\n",
							"            .saveAsTable(\"silver_sales.PhoneNumberType\")            "
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format(\"parquet\")\\\n",
							"            .load(\"abfss://bronze@dlcontoso.dfs.core.windows.net/sales/SalesPerson\")\n",
							"\n",
							"df = df.drop(col(\"SalesYTD\"), col(\"SalesLastYear\"), col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists(\"silver_sales.SalesPerson\"):\n",
							"    dlt_obj = DeltaTable.forName(spark, \"silver_sales.SalesPerson\")\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.BusinessEntityID = src.BusinessEntityID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"\n",
							"else:\n",
							"    df.write.format(\"delta\")\\\n",
							"            .mode(\"append\")\\\n",
							"            .option(\"path\", \"abfss://silver@dlcontoso.dfs.core.windows.net/sales/SalesPerson\")\\\n",
							"            .saveAsTable(\"silver_sales.SalesPerson\")            "
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Product"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/production/Product')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"df = df.withColumn(\"ProductLine\", trim(col(\"ProductLine\")))\\\n",
							"        .withColumn(\"Class\", trim(col(\"Class\")))\\\n",
							"        .withColumn(\"Style\", trim(col(\"Style\")))\n",
							"\n",
							"df = df.withColumn(\"ProductLine\", when(col(\"ProductLine\") == \"R\", \"Road\")\\\n",
							"                                    .when(col(\"ProductLine\") == \"M\", \"Mountain\")\\\n",
							"                                    .when(col(\"ProductLine\") == \"T\", \"Touring\")\\\n",
							"                                    .when(col(\"ProductLine\") == \"S\", \"Standard\")\\\n",
							"                                    .otherwise(\"General\")\n",
							"                )\n",
							"\n",
							"df = df.withColumn(\"Class\", when(col(\"Class\") == \"H\", \"High\")\\\n",
							"                            .when(col(\"Class\") == \"M\", \"Medium\")\\\n",
							"                            .when(col(\"Class\") == \"L\", \"Low\")\\\n",
							"                            .otherwise(\"Other\")\n",
							"                )\n",
							"\n",
							"df = df.withColumn(\"Style\", when(col(\"Style\") == \"M\", \"Men\")\\\n",
							"                            .when(col(\"Style\") == \"W\", \"Women\")\\\n",
							"                            .when(col(\"Style\") == \"U\", \"Universal\")\\\n",
							"                            .otherwise(\"No-Style\")\n",
							"                )\n",
							"\n",
							"if spark.catalog.tableExists('silver_sales.Product'):\n",
							"    dlt_obj = DeltaTable.forName(spark, 'silver_sales.Product')\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.ProductID = src.ProductID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"else:\n",
							"    df.write.format('delta')\\\n",
							"            .mode('append')\\\n",
							"            .option('path', 'abfss://silver@dlcontoso.dfs.core.windows.net/production/Product')\\\n",
							"            .saveAsTable('silver_sales.Product')"
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/production/ProductSubcategory')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"\n",
							"if spark.catalog.tableExists('silver_sales.ProductSubcategory'):\n",
							"    dlt_obj = DeltaTable.forName(spark, 'silver_sales.ProductSubcategory')\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.ProductSubcategoryID = src.ProductSubcategoryID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"else:\n",
							"    df.write.format('delta')\\\n",
							"            .mode('append')\\\n",
							"            .option('path', 'abfss://silver@dlcontoso.dfs.core.windows.net/production/ProductSubcategory')\\\n",
							"            .saveAsTable('silver_sales.ProductSubcategory')"
						],
						"outputs": [],
						"execution_count": 32
					},
					{
						"cell_type": "code",
						"source": [
							"df = spark.read.format('parquet')\\\n",
							"            .load('abfss://bronze@dlcontoso.dfs.core.windows.net/production/ProductCategory')\n",
							"\n",
							"df = df.drop(col(\"rowguid\"))\n",
							"\n",
							"if spark.catalog.tableExists('silver_sales.ProductCategory'):\n",
							"    dlt_obj = DeltaTable.forName(spark, 'silver_sales.ProductCategory')\n",
							"    dlt_obj.alias(\"trg\").merge(df.alias(\"src\"), \"trg.ProductCategoryID = src.ProductCategoryID\")\\\n",
							"                        .whenMatchedUpdateAll(condition=\"src.ModifiedDate > trg.ModifiedDate\")\\\n",
							"                        .whenNotMatchedInsertAll()\\\n",
							"                        .execute()\n",
							"else:\n",
							"    df.write.format('delta')\\\n",
							"            .mode('append')\\\n",
							"            .option('path', 'abfss://silver@dlcontoso.dfs.core.windows.net/production/ProductCategory')\\\n",
							"            .saveAsTable('silver_sales.ProductCategory')"
						],
						"outputs": [],
						"execution_count": 33
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SparkPool')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": 15
				},
				"autoScale": {
					"enabled": true,
					"maxNodeCount": 3,
					"minNodeCount": 3
				},
				"nodeCount": 10,
				"nodeSize": "Small",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "3.5",
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": false,
				"annotations": []
			},
			"dependsOn": [],
			"location": "centralindia"
		}
	]
}